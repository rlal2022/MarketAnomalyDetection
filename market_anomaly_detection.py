# -*- coding: utf-8 -*-
"""Market Anomaly Detection

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JFHcG_pNRTxCmJMmr8OxMjdMEie8c59A
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix

from google.colab import files
import pandas as pd

# Upload the file
uploaded = files.upload()

# Load the uploaded file into a DataFrame
for filename in uploaded.keys():
    print(f"You uploaded: {filename}")
    data = pd.read_csv(filename)
    print(data.head())

# Checking the column names and types
print(data.info())

# Checking for missing values
print(data.isnull().sum())

# Getting basic statistics
print(data.describe())

# Calculating percentage change in the Close price
data['Close_pct_change'] = data['Close'].pct_change()

# Defining a crash as a >5% drop in Close price
data['Crash'] = (data['Close_pct_change'] < -0.05).astype(int)

# Dropping NaN rows created by pct_change
data = data.dropna()

# Checking the distribution of the target
print(data['Crash'].value_counts())

# Defining features and target
X = data[['Close', 'Volume', 'Open', 'High', 'Low']]
y = data['Crash']

from sklearn.model_selection import train_test_split

# Splitting data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix

# Initializing and train the model
model = LogisticRegression()
model.fit(X_train, y_train)

# Making predictions
y_pred = model.predict(X_test)

# Evaluating the model
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

# Calculating probabilities for the ROC curve
y_pred_prob = model.predict_proba(X_test)[:, 1]
fpr, tpr, _ = roc_curve(y_test, y_pred_prob)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure()
plt.plot(fpr, tpr, label=f"ROC Curve (AUC = {roc_auc:.2f})")
plt.plot([0, 1], [0, 1], "k--")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("Receiver Operating Characteristic")
plt.legend(loc="lower right")
plt.show()

# Predicting crash probabilities for the test set
data['Crash_Probability'] = model.predict_proba(X)[:, 1]

# Adding model predictions to the dataset
data['Crash_Prediction'] = model.predict(X)

# column to track strategy actions
data['Investment_Action'] = data['Crash_Prediction'].apply(
    lambda x: 'Safe Assets' if x == 1 else 'Growth Investments'
)

# Calculating daily returns for growth investments
data['Daily_Returns'] = data['Close'].pct_change()

# Simulating returns based on the strategy
initial_investment = 10000  # Example: $10,000 starting capital
data['Portfolio_Value'] = initial_investment
portfolio = initial_investment

for i in range(1, len(data)):
    if data.iloc[i]['Investment_Action'] == 'Safe Assets':
        # No change in portfolio during crashes
        data.loc[data.index[i], 'Portfolio_Value'] = portfolio
    else:
        # Apply daily returns during growth investment periods
        portfolio *= (1 + data.iloc[i]['Daily_Returns'])
        data.loc[data.index[i], 'Portfolio_Value'] = portfolio

# Simulating a buy-and-hold portfolio
data['Buy_and_Hold'] = initial_investment * (1 + data['Daily_Returns']).cumprod()

# Plotting the results
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.plot(data['Portfolio_Value'], label='Strategy Portfolio')
plt.plot(data['Buy_and_Hold'], label='Buy-and-Hold Portfolio')
plt.xlabel('Date')
plt.ylabel('Portfolio Value')
plt.title('Strategy vs. Buy-and-Hold Performance')
plt.legend()
plt.show()

# Calculating key metrics
strategy_cumulative_return = (data['Portfolio_Value'].iloc[-1] / initial_investment) - 1
buy_and_hold_cumulative_return = (data['Buy_and_Hold'].iloc[-1] / initial_investment) - 1

print(f"Strategy Cumulative Return: {strategy_cumulative_return:.2%}")
print(f"Buy-and-Hold Cumulative Return: {buy_and_hold_cumulative_return:.2%}")

def investment_bot():
    print("Welcome to the Investment Bot!")
    print("I will help you understand market predictions and suggest investment strategies.\n")

    while True:
        print("\nOptions:")
        print("1. Explain current market prediction")
        print("2. Recommend investment action")
        print("3. Show historical strategy performance")
        print("4. Exit")

        choice = input("Choose an option (1-4): ")

        if choice == "1":
            # Example prediction explanation
            latest_prediction = data['Crash_Prediction'].iloc[-1]
            probability = data['Crash_Probability'].iloc[-1]
            if latest_prediction == 1:
                print(f"\nMarket Prediction: Crash likely (Probability: {probability:.2%}).")
            else:
                print(f"\nMarket Prediction: Stable market (Probability: {probability:.2%}).")

        elif choice == "2":
            # Example recommendation
            latest_action = data['Investment_Action'].iloc[-1]
            print(f"\nRecommended Action: {latest_action}")

        elif choice == "3":
            # Show final portfolio value and comparison
            strategy_value = data['Portfolio_Value'].iloc[-1]
            buy_and_hold_value = data['Buy_and_Hold'].iloc[-1]
            print(f"\nStrategy Final Portfolio Value: ${strategy_value:,.2f}")
            print(f"Buy-and-Hold Final Portfolio Value: ${buy_and_hold_value:,.2f}")

        elif choice == "4":
            print("\nThank you for using the Investment Bot! Goodbye!")
            break

        else:
            print("\nInvalid option. Please choose again.")

investment_bot()